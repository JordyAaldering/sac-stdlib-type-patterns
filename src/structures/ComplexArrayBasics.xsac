module ComplexArrayBasics;

use ComplexBasics: {complex};
#define OVERLOADS dim,shape,sel,reshape,genarray,modarray
use Array: all except {OVERLOADS};
import Array: {OVERLOADS};

export all;

#include "Templates.mac"

/******************************************************************************
 *
 * @fn int dim( complex[*] array)
 *
 * @brief yields an array's dimensionality (rank).
 *
 ******************************************************************************/
inline
int dim( complex[*] c)
{
  res = dim( (double[+])c) - 1;
  return( res);
}

/******************************************************************************
 *
 * @fn int[.] shape( complex[*] c)
 *
 * @brief yields an array's shape vector.
 *
 ******************************************************************************/
inline
int[.] shape( complex[*] c)
{
  res = drop( [-1], shape( (double[+])c));
  return( res);
}

/******************************************************************************
 *
 * @fn complex[*] sel( int idx, complex[*] c)
 *
 * @brief generalizes selections for scalar indices.
 *
 ******************************************************************************/
inline
complex[*] sel( int[.] idx, complex[*] c)
{
  v = ((double[+])c)[idx];
  res = (complex[*])v;
  return( res);
}

inline
complex[*] sel( int idx, complex[*] c)
{
  res = sel( [idx], c);
  return( res);
}

/******************************************************************************
 *
 * @fn double[*] norm( complex[*] array)
 *
 * @brief yields an array of norms
 *
 ******************************************************************************/
inline
double[d:shp] norm( complex[d:shp] c)
{
  res = with {
          (0*shp <= iv < shp)
            : ComplexBasics::norm( c[iv]);
        } : genarray( shp, 0d);
  return( res);
}

/******************************************************************************
 *
 * @fn double[*] normSq( complex[*] array)
 *
 * @brief yields an array of normSq
 *
 ******************************************************************************/
inline
double[d:shp] normSq( complex[d:shp] array)
{
  res = with {
          (0*shp <= iv < shp)
            : ComplexBasics::normSq( array[iv]);
        } : genarray( shp, 0d);
  return( res);
}

/******************************************************************************
 *
 * @fn complex[*] reshape( int[.] shp, complex[*] array)
 *
 * @brief creates a new array with identical data vector but new shape,
 *        provided the length of the data vector matches the product of
 *        the new shape vector.
 *
 ******************************************************************************
inline
complex[*] reshape( int[d] shp, complex[*] c)
{
  v = reshape( shp ++ [2], (double[*])c);
  res = (complex[*])v;
  return( res);
}
*/

/******************************************************************************
 *
 * @fn complex[*] genarray( int[.] shp, complex[*] val)
 *
 * @brief
 *
 ******************************************************************************/
inline
complex[n:shp,m:vshp] genarray( int[n] shp, complex[m:vshp] val)
{
  res = with {
          (0*shp <= iv < shp) : val;
        } : genarray( shp, val);
  return( res);
}

/******************************************************************************
 *
 * @fn complex[*] modarray( complex[*] array, int[.] idx, complex val)
 *
 * @brief modifies the element of array at position idx,
 *        provided shape(idx)[[0]] == dim(array) holds.
 *
 ******************************************************************************/
inline
complex[*] modarray( complex[*] array, int[.] idx, complex[*] val)
{
  res = with {
          (idx <= iv <= idx) : val;
        } : modarray( array);
  return( res);
}

inline
complex[*] modarray( complex[*] array, int idx, complex[*] val)
{
  res = modarray( array, [idx], val);
  return( res);
}
